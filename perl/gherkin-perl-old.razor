@using Berp;
@helper CallProduction(ProductionRule production)
{
  switch(production.Type)
  {
    case ProductionRuleType.Start:
@:##**//       startRule(context, '@production.RuleName');
@:       startRule($context, '@production.RuleName');
      break;
    case ProductionRuleType.End:
@:##**//       endRule(context, '@production.RuleName');
@:       endRule($context, '@production.RuleName');
      break;
    case ProductionRuleType.Process:
@:##**//       build(context, token);
@:       build($context, $token);
      break;
  }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
##**//     var stateComment = "State: @state.Id - @Raw(state.Comment)";
     my $stateComment = "State: @state.Id - @Raw(state.Comment)";
##**//     token.detach();
     $token->detach();
##**//     var expectedTokens = ["@Raw(string.Join("\", \"", expectedTokens))"];
     my $expectedTokens = ["@Raw(string.Join("\", \"", expectedTokens))"];
##**//     var error = token.isEof ?
     my $error = $token->isEof ?
##**//       Errors.UnexpectedEOFException.create(token, expectedTokens, stateComment) :
       Gherkin::Errors::UnexpectedEOFException->create(token, expectedTokens, stateComment) :
##**//       Errors.UnexpectedTokenException.create(token, expectedTokens, stateComment);
       Gherkin::Errors::UnexpectedTokenException->create(token, expectedTokens, stateComment);
##**//     if (this.stopAtFirstError) throw error;
     if ($self.stopAtFirstError) { die $error }
##**//     addError(context, error);
     addError($context, error);
##**//     return @state.Id;
     return @state.Id;
</text>}
@helper MatchToken(TokenType tokenType)
{<text>match_@(tokenType)(context, token)</text>}
##**// // This file is generated. Do not edit! Edit gherkin-javascript.razor instead.
package Gherkin::Parser;
# This file is generated. Do not edit! Edit gherkin-perl.razor instead.

use strict;
use warnings;

##**// var Errors = require('./errors');
use Gherkin::Errors;
##**// var AstBuilder = require('./ast_builder');
use Gherkin::AstBuilder;
##**// var TokenScanner = require('./token_scanner');
use Gherkin::TokenScanner;
##**// var TokenMatcher = require('./token_matcher');
use Gherkin::TokenMatcher;

##**//
##**// var RULE_TYPES = [
our $RULE_TYPES = [
##**//   'None',
   'None',
  @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
  {<text>##**//   '@rule.Name.Replace("#", "_")', // @rule.ToString(true)
   '@rule.Name.Replace("#", "_")', # @rule.ToString(true)
</text>}
##**// ];
 ];
##**//
##**// module.exports = function Parser(builder) {
##**//   builder = builder || new AstBuilder();
sub new {
    my $class = shift;
    my $builder = shift || Gherkin::AstBuilder->new();
##**//   var context;
    return bless {
      context => undef,
      builder => $builder,
    }, $class;
}
##**//
##**//   this.parse = function(tokenScanner, tokenMatcher) {
sub parse {
    my $tokenScanner = shift;
##**//     tokenMatcher = tokenMatcher || new TokenMatcher();
    my $tokenMatcher = shift || Gherkin::TokenMatcher->new();

##**//     if(typeof tokenScanner == 'string') {
##**//       tokenScanner = new TokenScanner(tokenScanner);
##**//     }

    # Create the TokenScanner obj if we were passed in a string
    $tokenScanner = Gherkin::TokenScanner->new( $tokenScanner )
        unless ref $tokenScanner;

##**//     builder.reset();
    $self->{'builder'}->reset();

##**//     tokenMatcher.reset();
    $tokenMatcher->reset();

##**//     context = {
##**//       tokenScanner: tokenScanner,
##**//       tokenMatcher: tokenMatcher,
##**//       tokenQueue: [],
##**//       errors: []
##**//     };
    $self->{'context'} = {
       tokenScanner => $tokenScanner,
       tokenMatcher => $tokenMatcher,
       tokenQueue => [],
       errors => [],
    };

##**//     startRule(context, 'Feature');
     $self->startRule('Feature');
##**//     var state = 0;
     my $state = 0;
##**//     var token = null;
     my $token = undef;
##**//     while(true) {
     while(1) {
##**//       token = readToken(context);
       $token = $self->readToken();
##**//       state = matchToken(state, token, context);
       $state = $self->matchToken($state, $token);
##**//       if(token.isEof) break;
       next if ( $token->isEof );
##**//     }
     }
##**//
##**//     endRule(context, 'Feature');
     $self->endRule('Feature');

##**//     if(context.errors.length > 0) {
##**//       throw Errors.CompositeParserException.create(context.errors);
##**//     }

     die Gherkin::Errors::CompositeParser->create(
         $context->{'errors'}
     ) if @@{ $context->{'errors'} };

##**//     return getResult();
     return getResult();
}


##**//   function addError(context, error) {
##**//     context.errors.push(error);
##**//     if (context.errors.length > 10)
##**//       throw Errors.CompositeParserException.create(context.errors);
##**//   }
sub addError {
    my ($self, $error) = @@_;

    push( @@{ $self->{'context'}->{'errors'} }, $error );
    die Errors::CompositeParser->create(
        $self->{'context'}->{'errors'}
    ) if @@{ $self->{'context'}->{'errors'} } > 10
}

##**//   function startRule(context, ruleType) {
##**//     handleAstError(context, function () {
##**//       builder.startRule(ruleType);
##**//     });
##**//   }
##**//   function endRule(context, ruleType) {
##**//     handleAstError(context, function () {
##**//       builder.endRule(ruleType);
##**//     });
##**//   }
##**//   function build(context, token) {
##**//     handleAstError(context, function () {
##**//       builder.build(token);
##**//     });
##**//   }
##**//   function handleAstError(context, action) {
##**//     handleExternalError(context, true, action)
##**//   }

sub startRule {
    my ( $self, $ruleType ) = @@_;
    $self->handleAstError( startRule => $ruleType );
}

sub endRule {
    my ( $self, $ruleType ) = @@_;
    $self->handleAstError( endRule => $ruleType );
}

sub build {
    my ( $self, $token ) = @@_;
    $self->handleAstError( build => $token );
}

sub handleAstError {
    my ( $self, $methodName, $arg ) = @@_;
    my $action = sub {
        $self->{'builder'}->$methodName( $arg );
    };

    $self->handleExternalError( 1, $action );
}

##**//   function getResult() {
##**//     return builder.getResult();
##**//   }
sub getResult {
    my $self = shift;
    return $self->{'builder'}->getResult();
}

##**//   function handleExternalError(context, defaultValue, action) {
##**//     if(this.stopAtFirstError) return action();
##**//     try {
##**//       return action();
##**//     } catch (e) {
##**//       if(e instanceof Errors.CompositeParserException) {
##**//         e.errors.forEach(function (error) {
##**//           addError(context, error);
##**//         });
##**//       } else if(
##**//         e instanceof Errors.ParserException ||
##**//         e instanceof Errors.AstBuilderException ||
##**//         e instanceof Errors.UnexpectedTokenException ||
##**//         e instanceof Errors.NoSuchLanguageException
##**//       ) {
##**//         addError(context, e);
##**//       } else {
##**//         throw e;
##**//       }
##**//     }
##**//     return defaultValue;
##**//   }
sub handleExternalError {
    my ( $self, $defaultValue, $action ) = @@_;
    return $action if $self->{'stopAtFirstError'};
    eval { $action->() };
    if ( my $error = $@@ ) {
        if ( ref $error ) {
            if ( $error->isa('Gherkin::Errors::CompositeParser') ) {
                $self->addError( $_ ) for @@{ $error->errors };
            } elsif (
                grep map { $_->isa("Gherkin::Errors::$_") }
                    qw/Parser AstBuilder UnexpectedToken NoSuchLanguage/
            ) {
                $self->addError( $error );
            } else {
                die $error;
            }
        } else {
            die $error;
        }
    }

    return $defaultValue;
}

##**//   function readToken(context) {
##**//     return context.tokenQueue.length > 0 ?
##**//       context.tokenQueue.shift() :
##**//       context.tokenScanner.read();
##**//   }

sub readToken {
    return
        shift( @@{ $self->{'content'}->{'tokenQueue'} } ) //
        $self->{'content'}->{'tokenScanner'}->read();
}

##**//   function matchToken(state, token, context) {
##**//     switch(state) {
##**// blah blah blah
##**//     default:
##**//       throw new Error("Unknown state: " + state);
##**//     }
##**//   }
my $statesToMethodNames = {
    @foreach(var state in Model.States.Values.Where(s => !s.IsEndState)) //.
    {
@:    @state.Id => "matchTokenAt_@(state.Id)",
    }
};

sub matchToken {
    my ( $self, $state, $token, $context ) = @@_;
    my $methodName = $statesToMethodNames{ $state } || die "Unknown state: $state";
    $self->$methodName( $state, $context );
}

@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
##**//   // @Raw(state.Comment)
   // @Raw(state.Comment)
##**//   function matchTokenAt_@(state.Id)(token, context) {
   function matchTokenAt_@(state.Id)(token, context) {
    @foreach(var transition in state.Transitions)
    {
@:##**//     if(@MatchToken(transition.TokenType)) {
@:     if(@MatchToken(transition.TokenType)) {
      if (transition.LookAheadHint != null)
      {
@:##**//       if(lookahead_@(transition.LookAheadHint.Id)(context, token)) {
@:       if(lookahead_@(transition.LookAheadHint.Id)(context, token)) {
      }
      foreach(var production in transition.Productions)
      {
         @CallProduction(production)
      }
@:##**//       return @transition.TargetState;
@:       return @transition.TargetState;
      if (transition.LookAheadHint != null)
      {
@:##**//       }
@:       }
      }
@:##**//     }
@:     }
    }
    @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
##**//   }
   }
</text>
}

@foreach(var rule in Model.RuleSet.TokenRules)
{
<text>
##**//   function match_@(rule.Name.Replace("#", ""))(context, token) {
   function match_@(rule.Name.Replace("#", ""))(context, token) {
     @if (rule.Name != "#EOF")
     {
@:##**//     if(token.isEof) return false;
@:     if(token.isEof) return false;
     }
    return handleExternalError(context, false, function () {
      return context.tokenMatcher.match_@(rule.Name.Replace("#", ""))(token);
    });
  }
</text>
}

@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
##**//   function lookahead_@(lookAheadHint.Id)(context, currentToken) {
   function lookahead_@(lookAheadHint.Id)(context, currentToken) {
##**//     currentToken.detach();
     currentToken.detach();
##**//     var token;
     var token;
##**//     var queue = [];
     var queue = [];
##**//     var match = false;
     var match = false;
##**//     do {
     do {
##**//       token = readToken(context);
       token = readToken(context);
##**//       token.detach();
       token.detach();
##**//       queue.push(token);
       queue.push(token);
##**//
##**//       if (false @foreach(var tokenType in lookAheadHint.ExpectedTokens) { <text>|| @MatchToken(tokenType)</text>}) {
       if (false @foreach(var tokenType in lookAheadHint.ExpectedTokens) { <text>|| @MatchToken(tokenType)</text>}) {
##**//         match = true;
         match = true;
##**//         break;
         break;
##**//       }
       }
##**//     } while(false @foreach(var tokenType in lookAheadHint.Skip) { <text>|| @MatchToken(tokenType)</text>});
     } while(false @foreach(var tokenType in lookAheadHint.Skip) { <text>|| @MatchToken(tokenType)</text>});
##**//
##**//     context.tokenQueue = context.tokenQueue.concat(queue);
     context.tokenQueue = context.tokenQueue.concat(queue);
##**//
##**//     return match;
     return match;
##**//   }
   }
</text>
}

}
